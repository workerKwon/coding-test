'''
가장 큰 수와 두 번째로 큰 수가 더해질 때는 특정한 수열 형태로 일정하게 반복해서 더해지는 특징이 있다.
반복되는 수열의 길이는 K+1회이다. 왜냐하면 하나의 인덱스에 해당하는 값이 최대 반복해서 더해질 수 있는 회수가 K번이고 그 다음 한번만 두번째로 큰 수를 더해주면 되기 때문이다.
따라서 M을 K+1로 나눈 몫이 수열이 반복되는 횟수가 된다. 이 때 M이 K+1로 나누어 떨어지지 않을 경우도 고려해야한다.
M / (K+1)의 나머지 만큼 가장 큰 수가 반복해서 더해진다.
'''

n, m, k = map(int, input().split())
data = list(map(int, input().split()))

data.sort()
first = data[n-1]
second = data[n-2]

# 가장 큰 수가 더해지는 횟수 구하기
count = int(m/(k+1)) * k # k+1은 반복되는 수열의 횟수이다. 총 연산 횟수를 수열의 길이로 나누면 수열을 몇번 반복하는지 나온다. 거기에 k를 곱하면 가장 큰 수를 몇번 더해야하는지 나온다.
count += m % (k+1) # m/(k+1)이 나누어 떨어지지 않을 때 나머지만큼 가장 큰 수를 더해준다.

result = 0
result += (count) * first # 가장 큰 수를 더해야 하는 횟수 * 가장 큰 수. 여기서 가장 큰 수의 덧셈은 끝.
result += (m - count) * second # 총 연산 횟수에서 가장 큰수의 덧셈 횟수를 빼면 두번째 큰 수의 연산 횟수가 나온다.

print(result)
