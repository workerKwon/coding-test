"""
남규는 통나무를 세워 놓고 건너뛰기를 좋아한다. 그래서 N개의 통나무를 원형으로 세워 놓고 뛰어놀려고 한다.
남규는 원형으로 인접한 옆 통나무로 건너뛰는데, 이때 각 인접한 통나무의 높이 차가 최소가 되게 하려 한다.

통나무 건너뛰기의 난이도는 인접한 두 통나무 간의 높이의 차의 최댓값으로 결정된다.
높이가 {2, 4, 5, 7, 9}인 통나무들을 세우려 한다고 가정하자. 이를 [2, 9, 7, 4, 5]의 순서로 세웠다면, 가장 첫 통나무와 가장 마지막 통나무 역시 인접해 있다.
즉, 높이가 2인 것과 높이가 5인 것도 서로 인접해 있다.
배열 [2, 9, 7, 4, 5]의 난이도는 |2-9| = 7이다. 우리는 더 나은 배열 [2, 5, 9, 7, 4]를 만들 수 있으며 이 배열의 난이도는 |5-9| = 4이다.
이 배열보다 난이도가 낮은 배열은 만들 수 없으므로 이 배열이 남규가 찾는 답이 된다.

입력
입력은 T개의 테스트 케이스로 이루어져 있다. 첫 줄에 T가 주어진다.
이어지는 각 줄마다 첫 줄에 통나무의 개수를 나타내는 정수 N(5 ≤ N ≤ 10,000), 둘째 줄에 각 통나무의 높이를 나타내는 정수 Li가 주어진다. (1 ≤ Li ≤ 100,000)

출력
각 테스트 케이스마다 한 줄에 주어진 통나무들로 만들 수 있는 최소 난이도를 출력하시오.


풀이
통나무를 오름차순으로 정렬하고 뒤에서부터(큰 것 부터) 먼저 놓고 왼쪽 오른쪽 번갈아가면서 두면 인접해 있는 통나무는 오름차순으로 정렬되어 있을 때의 인덱스 1개 혹은 2개 씩 차이가 날 것이다.

                가장 큰 수를 가운데                          오름차순 정렬
                     9                                      2  (4와는 1인덱스, 5와는 2인덱스 차이가 난다)
               7            5                          4          9
                  4     2  (4, 5와 인접해 있다.)              5    7

즉, 오름차순 정렬해놓고 2인덱스 차이가 나는 통나무와 비교하면 가장 큰 차이를 구할 수 있다.
"""


T = int(input())

result = []
for i in range(T):
    logs = int(input())
    logs_height_list = list(map(int, input().split()))
    logs_height_list.sort()
    init = 0 # 통나무 높이 리스트에서 가장 큰 차이가 나는 수 초기화
    for j in range(2, logs): # j는 2부터 시작
        diff = logs_height_list[j] - logs_height_list[j-2] # j번째 통나무와 j-2번째 통나무 차이 구하기
        init = max(diff, init) # 가장 큰 차이 저장
    result.append(init) # 가장 큰 차이 저장.
print(*result)



